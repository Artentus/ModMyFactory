using ModMyFactory.Helpers;
using System;
using System.IO;
using System.IO.Compression;
using System.Threading.Tasks;

namespace ModMyFactory.Models
{
    sealed class FactorioFolder
    {
        const string Win32BinName = "Win32";
        const string Win64BinName = "x64";

        public DirectoryInfo Directory { get; private set; }

        public FileInfo Executable { get; private set; }

        public Version Version { get; }

        public bool Is64Bit { get; }
        
        /// <summary>
        /// Renames this Factorio folder to a unique name.
        /// </summary>
        public void RenameToUnique()
        {
            if (!IsUniqueName(Directory.Name))
            {
                string newPath = Path.Combine(Directory.Parent.FullName, GenerateUniqueName());
                Directory.MoveTo(newPath);
            }
        }

        /// <summary>
        /// Copies this Factorio folder to a new directory.
        /// </summary>
        public async Task<FactorioFolder> CopyToAsync(DirectoryInfo destination)
        {
            if (!destination.Exists) destination.Create();

            var dir = new DirectoryInfo(Directory.FullName);
            await dir.CopyToAsync(destination.FullName);

            var newDir = new DirectoryInfo(Path.Combine(destination.FullName, dir.Name));
            string executablePath = Is64Bit ? $@"bin\{Win64BinName}\factorio.exe" : $@"bin\{Win32BinName}\factorio.exe";
            var executable = new FileInfo(Path.Combine(newDir.FullName, executablePath));

            return new FactorioFolder(newDir, executable, Version, Is64Bit);
        }

        /// <summary>
        /// Moves this Factorio folder to a new directory.
        /// </summary>
        public async Task MoveToAsync(DirectoryInfo destination)
        {
            if (!destination.Exists) destination.Create();

            var newDir = new DirectoryInfo(Path.Combine(destination.FullName, Directory.Name));
            await Directory.MoveToAsync(destination.FullName);
            Directory = newDir;

            string executablePath = Is64Bit ? $@"bin\{Win64BinName}\factorio.exe" : $@"bin\{Win32BinName}\factorio.exe";
            Executable = new FileInfo(Path.Combine(newDir.FullName, executablePath));
        }

        private FactorioFolder(DirectoryInfo directory, FileInfo executable, Version version, bool is64Bit)
        {
            Directory = directory;
            Executable = executable;
            Version = version;
            Is64Bit = is64Bit;
        }

        /// <summary>
        /// Generates a unique directory name.
        /// </summary>
        private static string GenerateUniqueName()
        {
            var guid = Guid.NewGuid();
            return guid.ToString("B");
        }

        /// <summary>
        /// Determines if a given name has been generated by <see cref="GenerateUniqueName"/>.
        /// </summary>
        private static bool IsUniqueName(string name)
        {
            return Guid.TryParseExact(name, "B", out var guid);
        }

        private static bool TryLoadVersion(DirectoryInfo directory, out Version Version)
        {
            Version = null;

            var baseModDir = new DirectoryInfo(Path.Combine(directory.FullName, @"data\base"));
            if (!baseModDir.Exists) return false;

            ModFile modFile;
            if (!ModFile.TryLoadFromDirectory(baseModDir, out modFile)) return false;
            
            Version = modFile.Version;
            return (modFile.Name == "base");
        }

        private static bool TryLoadExecutable(DirectoryInfo directory, out FileInfo executable)
        {
            executable = new FileInfo(Path.Combine(directory.FullName, "factorio.exe"));
            return executable.Exists;
        }

        private static bool TryLoadBitness(DirectoryInfo directory, out bool is64Bit, out FileInfo executable)
        {
            var win32Dir = new DirectoryInfo(Path.Combine(directory.FullName, $@"bin\{Win32BinName}"));
            var win64Dir = new DirectoryInfo(Path.Combine(directory.FullName, $@"bin\{Win64BinName}"));

            if (win64Dir.Exists && TryLoadExecutable(win64Dir, out executable))
            {
                is64Bit = true;
                return true;
            }
            else if (win32Dir.Exists && TryLoadExecutable(win32Dir, out executable))
            {
                is64Bit = false;
                return true;
            }
            else
            {
                is64Bit = false;
                executable = null;
                return false;
            }
        }

        public static bool TryLoad(DirectoryInfo directory, out FactorioFolder folder)
        {
            folder = null;

            if (!directory.Exists) return false;
            if (!TryLoadVersion(directory, out var version)) return false;
            if (!TryLoadBitness(directory, out bool is64Bit, out var executable)) return false;

            folder = new FactorioFolder(directory, executable, version, is64Bit);
            return true;
        }

        public static async Task<FactorioFolder> FromFileAsync(FactorioFile file, DirectoryInfo destination)
        {
            if (!destination.Exists) destination.Create();
            await Task.Run(() => ZipFile.ExtractToDirectory(file.ArchiveFile.FullName, destination.FullName));

            var dir = new DirectoryInfo(Path.Combine(destination.FullName, $"Factorio_{file.Version}"));
            if (!dir.Exists) throw new InvalidOperationException("The given file contained invalid data.");
            dir.MoveTo(Path.Combine(destination.FullName, GenerateUniqueName()));

            string executablePath = file.Is64Bit ? $@"bin\{Win64BinName}\factorio.exe" : $@"bin\{Win32BinName}\factorio.exe";
            var executable = new FileInfo(Path.Combine(dir.FullName, executablePath));
            return new FactorioFolder(dir, executable, file.Version, file.Is64Bit);
        }
    }
}
